<h1 align="center">
  <a href="https://github.com/haw230/the-anadromi-project"><img src="https://github.com/haw230/the-anadromi-project/blob/pictures/anadromi_logo.png" alt="A" width="170"></a>
  <br>
  The Anadromi Project
  <br>
</h1>

The Anadromi Project (TAP) is an innovative approach to computer science education. Armed with Python, this revolutionary open source program focuses on teaching the bright leaders of tomorrow necessary tools for **recursive problem solving** and **algorithmic thinking**. These skills are applicable and essential to both the computer science field as well as other disciplines.

## Table of Contents
1. [Prerequisites](#prerequisites "What you might want to know before starting")
2. [Stage 1: Hill Climbing](#stage-1-hill-climbing "First stage!")   
    * [Linear Search](#linear-search "A simple way to search")
    * [Selection Sort](#selection-sort "A simple way to sort")
    * [Bubble Sort](#bubble-sort "Another simple way to sort")
    * [Time Complexity Part 1](#time-complexity-part-1 "Measuring efficency")
3. [Stage 2: Gaining Speed](#stage-2-gaining-speed "Stage stage!")
    * [Binary Search](#binary-search "Efficent way to search")
    * [Merge Sort](#merge-sort "Efficent way to sort")
    * [Quicksort](#quicksort "A very quick way to sort")
    * [Time Complexity Part 2](#time-complexity-part-1 "More measuring efficency!")
    * [Tower of Hanoi](#tower-of-hanoi "Solve a logic puzzle!")
4. [Stage 3: At the Top](#stage-3-at-the-top "Final stage!")
    * [Greedy](#greedy "Greedy but short-sighted")
    * [Binary Search Tree](#binary-search-tree "Optimal but tiring")
    * [Dynamic Programming](#dynamic-programming "Optimizing the tree")
5. [License](#license)
6. [Acknowledgements](#acknowledgements)

## Prerequisites
Students should be somewhat comfortable the basic concepts of programming: 
- [x] Variables and simple data types
- [x] Loops
- [x] Conditional operators
- [x] Functions

## Stage 1: Hill Climbing
This stage will focus on simple but inefficent algorithms that neatly fuse the basics of programming, preparing the student for more advanced concepts.
### [Linear Search](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing/1-linear-search)
Students will start off with a basic implementation of a linear search, a search algorithm that finds the index of a specific element in a list.

### [Selection Sort](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing/2-selection-sort)
This program will use the selection sort algorithm to sort an unordered list.

### [Bubble Sort](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing/3-bubble-sort)
Another sorting algorithm exercise to practice coding skills.

### [Time Complexity Part 1](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing/4-time-complexity-part-1)
This rather abstract concept is introduced rather early on in order to demonstrate the efficency of the previously learned algorithms. Time complexity provides a nice segway into recursion and answers the question to *why* we need these efficent yet terribly complex algorithms.

## Stage 2: Gaining Speed
This stage focuses on the transition to more complicated algorithms that introduce recursion.

### Binary Search
Binary search is a searching algorithm that works only on ordered lists, though far faster than the previous linear search. The theory behind it is not difficult to understand, but it will introduce the Three Laws of Recursion and feature its application.

### Merge Sort
Merge sort builds on the recursive foundation binary search introduced previously, sorting a list far faster than selection sort and bubble sort by a large margin.

### Quicksort
The most modern of sorting algorithms, quicksort depicts the mastery of recursion and shows readiness to move onto dynamic programming.

### Time Complexity Part 2
More on time complexity that will include these three new recursive algorithms.

### Tower of Hanoi
Hone your skills with a common mathematical puzzle that can be solved through recursion.

## Stage 3: At the Top
Using everything learned from the previous lessons, the student will create different algorithmic solutions to the knapsack problem. This is the capstone project of the program.

### Greedy
Imagine that you have an empty bag which  you must fill with items, each of these items containing an arbitrary value and cost when taken. What would you take? How can you take the *best* choice? This particular implementation will focus on the greedy algorithm, the philosophy of taking what seems to be the most valuable at the moment.

### Binary Search Tree
Rather than greedily taking whatever is most valuable, the binary search tree algorithm will search **all** combinations of items and then decide what is *best*.

### Dynamic Programming
Dynamic programming will build on the binary search tree implementation, improving the efficency of the program.

## License
The Anadromi Project is released under the terms of the [MIT License](http://www.opensource.org/licenses/MIT "MIT License").

## Acknowledgements
* University of Alberta's [High School Internship Program](https://www.ualberta.ca/computing-science/explore/hs-internships "High School Internship Program")
* Supervisor Cody Steinke
* Logo designer [Seth Hinz](https://github.com/shinzlet "GitHub Handle")
