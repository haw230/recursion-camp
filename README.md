<h1 align="center">
  <a href="https://github.com/haw230/the-anadromi-project"><img src="https://github.com/haw230/the-anadromi-project/blob/pictures/anadromi_logo.png" alt="A" width="170"></a>
  <br>
  The Anadromi Project
  <br>
</h1>

[![license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/haw230/the-anadromi-project/master/LICENSE)
[![tweet](https://img.shields.io/twitter/url/https/github.com/haw230/the-anadromi-project.svg?style=social)](https://twitter.com/anadromi)

The Anadromi Project is an innovative approach to computer science education. Armed with Python, this revolutionary open source program focuses on teaching the bright leaders of tomorrow necessary tools for **recursive problem solving** and **algorithmic thinking**. These skills are applicable and essential to both the computer science field as well as other disciplines.

## Table of Contents
1. [Prerequisites](#prerequisites "What you might want to know before starting")
2. [Stage 1: Hill Climbing](#stage-1-hill-climbing "First stage!")   
    * [Linear Search](#linear-search "A simple way to search")
    * [Selection Sort](#selection-sort "A simple way to sort")
    * [Bubble Sort](#bubble-sort "Another simple way to sort")
    * [Time Complexity Part 1](#time-complexity-part-1 "Measuring efficency")
3. [Stage 2: Gaining Speed](#stage-2-gaining-speed "Stage stage!")
    * [Binary Search](#binary-search "Efficent way to search")
    * [Merge Sort](#merge-sort "Efficent way to sort")
    * [Quicksort](#quicksort "A very quick way to sort")
    * [Time Complexity Part 2](#time-complexity-part-1 "More measuring efficency!")
4. [Stage 3: At the Top](#stage-3-at-the-top "Final stage!")
    * [Iterative Fibonacci](#iterative-fibonacci "Iterative but inelegant")
    * [Recursive Fibonacci](#recursive-fibonacci "Optimal but tiring")
    * [Dynamic Fibonacci](#dynamic-fibonacci "Optimizing the tree")
5. [License](#license)
6. [Acknowledgements](#acknowledgements)

## Prerequisites
Students should be mostly comfortable the basic concepts of programming: 
- [x] Variables and simple data types
- [x] Loops
- [x] Conditional operators
- [x] Functions

## [Stage 1: Hill Climbing](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing)
This stage will focus on simple but inefficent algorithms that neatly fuse the basics of programming, preparing the student for more advanced concepts.
### [Linear Search](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing/1-linear-search)
Students will start off with a basic implementation of a linear search, a search algorithm that finds the index of a specific element in a list.

### [Selection Sort](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing/2-selection-sort)
This program will use the selection sort algorithm to sort an unordered list.

### [Bubble Sort](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing/3-bubble-sort)
Another sorting algorithm exercise to practice coding skills.

### [Time Complexity Part 1](https://github.com/haw230/the-anadromi-project/tree/master/stage-1-hill-climbing/4-time-complexity-part-1)
This rather abstract concept is introduced rather early on in order to demonstrate the efficency of the previously learned algorithms. Time complexity provides a nice segway into recursion and answers the question to *why* we need these efficent yet terribly complex algorithms.

## [Stage 2: Gaining Speed](https://github.com/haw230/the-anadromi-project/tree/master/stage-2-gaining-speed)
This stage focuses on the transition to more complicated algorithms that introduce recursion.

### [Binary Search](https://github.com/haw230/the-anadromi-project/tree/master/stage-2-gaining-speed/1-binary-search)
Binary search is a searching algorithm that works only on ordered lists, though far faster than the previous linear search. The theory behind it is not difficult to understand, but it will introduce the Three Laws of Recursion and feature its application.

### [Merge Sort](https://github.com/haw230/the-anadromi-project/tree/master/stage-2-gaining-speed/2-merge-sort)
Merge sort builds on the recursive foundation binary search introduced previously, sorting a list far faster than selection sort and bubble sort by a large margin.

### [Quicksort](https://github.com/haw230/the-anadromi-project/tree/master/stage-2-gaining-speed/3-quicksort)
The most modern of sorting algorithms, quicksort depicts the mastery of recursion and shows readiness to move onto dynamic programming.

### [Time Complexity Part 2](https://github.com/haw230/the-anadromi-project/tree/master/stage-2-gaining-speed/4-time-complexity-part-2)
More on time complexity that will include these three new recursive algorithms.

## [Stage 3: At the Top](https://github.com/haw230/the-anadromi-project/tree/master/stage-3-at-the-top)
Using everything learned from the previous lessons, the student will implement the Fibonacci sequence.

### [Iterative Fibonacci](https://github.com/haw230/the-anadromi-project/tree/master/stage-3-at-the-top/1-iter-fibonacci)
Solve Fibonacci with brute force.

### [Recursive Fibonacci](https://github.com/haw230/the-anadromi-project/tree/master/stage-3-at-the-top/2-binary-search-tree)
Solve Fibonacci recursively with a search tree.

### [Dynamic Fibonacci](https://github.com/haw230/the-anadromi-project/tree/master/stage-3-at-the-top/3-dynamic-programming)
Dynamic programming will build on the binary search tree implementation, improving the efficency of the program.

## License
The Anadromi Project is released under the terms of the [MIT License](http://www.opensource.org/licenses/MIT "MIT License").

## Acknowledgements
* University of Alberta's [High School Internship Program](https://www.ualberta.ca/computing-science/explore/hs-internships "High School Internship Program")
* Supervisor Cody Steinke
* Logo designer [Seth Hinz](https://github.com/shinzlet "GitHub Handle")
